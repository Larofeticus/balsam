The Balsam Database
===================

Every Balsam instance is associated with a **database** of jobs. If you use the
Balsam scheduling service, it will package and submit these jobs for concurrent
ensemble execution. You can also bypass the service and directly run the Balsam
launcher, which is the pilot responsible for processing and executing jobs
concurrently. 

When Balsam is first installed, a SQLite database is created in the default **Balsam DB directory**.
This directory is named ``default_balsamdb`` and located in the top level of the Balsam repo.
Each Balsam DB directory contains the following files:

db.sqlite3
    The actual database (in the case of SQLite, a single file) on disk. For
    heavy duty databases like Postgres, this file is replaced by a entire
    directory containing the various database files

dbwriter_address
    JSON datastore used to coordinate database clients and servers
   
data/
    Directory containing all the output and files generated by your jobs. The
    data/ directory is organized by subdirectories for each workflow name.  All
    jobs assigned to the same workflow will be placed in the same folder. This
    workflow folder then contains all the working directories of its jobs,
    which are given unique names based on the given job name.

log/
    Log files, which are very useful to monitor the state and health of the Balsam applicaitons, are 
    written into this logging subdirectory.

Creating a new Balsam DB
--------------------------

You may want to set up one or more Balsam DB directories for different
projects; or perhaps one SQLite DB for testing and a heavier-duty one for
production. Create a new Balsam DB simply by specifying the path of the new
directory::

    $ balsam init ~/testdb --db-type sqlite3

This will create a new directory and populate it with the files mentioned
above. If you ever ``git pull`` and the database schema goes out-of-date, 
you can also use this command to refresh the existing DB.

Starting up the Balsam DB Server
----------------------------------
With SQLite3, processes that use the Balsam DB can simply make a direct connection by opening the file on disk.
This approach breaks down when independent processes (e.g. the metascheduler and launcher) or user applications
try to **write concurrently** to the database. Because SQLite+Django has poor support for concurrency, Balsam
provides a DB proxy service, which runs in front of the database and serializes all calls to write through a 
ZeroMQ socket. Start and stop the DB server with::
    
    $ balsam dbserver --path=~/testdb
    $ balsam dbserver --stop

This will run a "watchdog" process that keeps the server alive and establishes
the appropriate port for TCP communication to the server.  All programs in your
workflow will automatically communicate with this server instead of trying to
write directly to the DB. 

In the case of Postgres or MySQL, running the **dbserver command is not
optional**, because **all** DB read and write queries are handled by the
server! Fortunately, the details of setting up and running a DB server are
completely encapsulated by the commands ``balsam init`` and ``balsam
dbserver``.

Specifying which DB to use
----------------------------

If you constantly want to use one Balsam DB other than ``default_balsamdb/``,
you can change the path in ``balsam/user_settings.py``.  Set the variable
``default_db_path`` at the top of the file equal to the full path of your DB
directory.

To override the ``default_db_path`` for a particular session, you can set the environment
variable ``BALSAM_DB_PATH``.  Either export this variable or prefix your command lines with 
it, for instance::
    
    $ BALSAM_DB_PATH=~/testdb balsam ls  # will list jobs in the ~/testdb location
    $
    $ # or equivalently...
    $ export BALSAM_DB_PATH=~/testdb
    $ balsam ls
